      							библиотеки
from selenium import webdriver
from selenium.webdriver.common.by import By
import time
import math
from selenium.webdriver.chrome.service import Service
import warnings                                                 #для скрытия предупреждения      пример:   warnings.filterwarnings("ignore", category=DeprecationWarning)

from selenium.webdriver.support.ui import Select                #                           

						  поиск плейхолдера
last_name = browser.find_element(By.XPATH, "//input[@placeholder = 'Input your last name']")
        last_name.send_keys('Vasilev')


                                                   Работа со списками
#http://suninjuly.github.io/selects1.html

from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get(link)


browser.find_element(By.TAG_NAME, "select").click()
browser.find_element(By.CSS_SELECTOR, "option:nth-child(2)").click()   # или browser.find_element(By.CSS_SELECTOR, "[value='1']").click()

                                                    2  вариант

from selenium.webdriver.support.ui import Select
select = Select(browser.find_element(By.TAG_NAME, "select"))
select.select_by_value("1") # ищем элемент с текстом "Python"

#Можно использовать еще два метода: select.select_by_visible_text("text") и select.select_by_index(index).
#Первый способ ищет элемент по видимому тексту, например, select.select_by_visible_text("Python") найдёт "Python" для нашего примера.

#Второй способ ищет элемент по его индексу или порядковому номеру.
#Индексация начинается с нуля. Для того чтобы найти элемент с текстом "Python", нужно использовать select.select_by_index(1),
#так как опция с индексом 0 в данном примере имеет значение по умолчанию равное "--".

                                                Метод execute_script
from selenium import webdriver
browser = webdriver.Chrome()
browser.execute_script("alert('Robots at work');")
Обратите внимание, что исполняемый JavaScript нужно заключать в кавычки (двойные или одинарные).
Если внутри скрипта вам также понадобится использовать кавычки,
а для выделения скрипта вы уже используете двойные кавычки, то в скрипте следует поставить одинарные:

browser.execute_script("document.title='Script executing';")
Такой формат записи тоже будет работать:

browser.execute_script('document.title="Script executing";')
Можно с помощью этого метода выполнить сразу несколько инструкций, перечислив их через точку с запятой.
Изменим сначала заголовок страницы, а затем вызовем alert:

browser.execute_script("document.title='Script executing';alert('Robots at work');")

Чтобы кликнуть на перекрытую кнопку, нам нужно выполнить следующие команды в коде:

button = browser.find_element_by_tag_name("button")
browser.execute_script("return arguments[0].scrollIntoView(true);", button)
button.click()

                                                           Загрузка файлов
Если нам понадобится загрузить файл на веб-странице, мы можем использовать уже знакомый нам метод send_keys. 
Только теперь нам нужно в качестве аргумента передать путь к нужному файлу на диске вместо простого текста.

import os 
current_dir = os.path.abspath(os.path.dirname(__file__))    # получаем путь к директории текущего исполняемого файла 
file_path = os.path.join(current_dir, 'file.txt')           # добавляем к этому пути имя файла 
element.send_keys(file_path)
                                                          Alerts
переключиться на окно с alert, а затем принять его с помощью команды accept():
alert = browser.switch_to.alert
alert.accept()

Чтобы получить текст из alert, используйте свойство text объекта alert:
alert = browser.switch_to.alert
alert_text = alert.text

Другой вариант модального окна, который предлагает пользователю выбор согласиться с сообщением или отказаться от него, называется confirm.
Для переключения на окно confirm используется та же команда, что и в случае с alert:

confirm = browser.switch_to.alert
confirm.accept()

Для confirm-окон можно использовать следующий метод для отказа:

confirm.dismiss()
То же самое, что и при нажатии пользователем кнопки "Отмена". 

Третий вариант модального окна — prompt — имеет дополнительное поле для ввода текста. Чтобы ввести текст, используйте метод send_keys():

prompt = browser.switch_to.alert
prompt.send_keys("My answer")
prompt.accept()
                                                    Переход на новую вкладку браузера
При работе с веб-приложениями приходится переходить по ссылкам, которые открываются в новой вкладке браузера.
WebDriver может работать только с одной вкладкой браузера. При открытии новой вкладки WebDriver продолжит работать со старой вкладкой.
Для переключения на новую вкладку надо явно указать, на какую вкладку мы хотим перейти. Это делается с помощью команды switch_to.window:

browser.switch_to.window(window_name)
Чтобы узнать имя новой вкладки, нужно использовать метод window_handles, который возвращает массив имён всех вкладок.
Зная, что в браузере теперь открыто две вкладки, выбираем вторую вкладку:

new_window = browser.window_handles[1]
Также мы можем запомнить имя текущей вкладки, чтобы иметь возможность потом к ней вернуться:

first_window = browser.window_handles[0]
После переключения на новую вкладку поиск и взаимодействие с элементами будут происходить уже на новой странице.

                                                задержка при помощи библиотеки time.
import time
time.sleep(1)       #устанавливаем задержку в 1 сек
						Selenium Waits (Implicit Waits)
						
В Selenium WebDriver есть специальный способ организации такого ожидания, 
который позволяет задать ожидание при инициализации драйвера, чтобы применить его ко всем тестам. 
Ожидание называется неявным (Implicit wait), так как его не надо явно указывать каждый раз, когда мы выполняем поиск элементов,
оно автоматически будет применяться при вызове каждой последующей команды.

browser.implicitly_wait(5)
			
							Явные ожидания (Explicit Waits)
							
в Selenium WebDriver существует понятие явных ожиданий (Explicit Waits), которые позволяют задать специальное ожидание для конкретного элемента.
Задание явных ожиданий реализуется с помощью инструментов WebDriverWait и expected_conditions

from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium import webdriver

browser = webdriver.Chrome()

browser.get("http://suninjuly.github.io/wait2.html")

# говорим Selenium проверять в течение 5 секунд, пока кнопка не станет кликабельной
button = WebDriverWait(browser, 5).until(
        EC.element_to_be_clickable((By.ID, "verify"))
    )
button.click()
message = browser.find_element(By.ID, "verify_message")

assert "successful" in message.text
element_to_be_clickable вернет элемент, когда он станет кликабельным, или вернет False в ином случае.

в объекте WebDriverWait используется функция until, в которую передается правило ожидания, элемент, а также значение, по которому мы будем искать элемент.
В модуле expected_conditions есть много других правил, которые позволяют реализовать необходимые ожидания:

title_is
title_contains
presence_of_element_located
visibility_of_element_located
visibility_of
presence_of_all_elements_located

          text_to_be_present_in_element    
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait
#button = WebDriverWait(browser, время).until(EC.text_to_be_present_in_element((By.ID, "здесь пишем ID"),"здесь пишем текст))

text_to_be_present_in_element_value
frame_to_be_available_and_switch_to_it
invisibility_of_element_located
element_to_be_clickable
staleness_of
element_to_be_selected
element_located_to_be_selected
element_selection_state_to_be
element_located_selection_state_to_be
alert_is_present

                                                           Составные сообщения об ошибках 
assert self.is_element_present('new_announcement_button', timeout=30), "No new announcement button on profile page"

                                                           Форматирование строк с помощью str.format
							   
print("Let's count together: {}, then goes {}, and then {}".format("one", "two", "three"))
Таким образом мы можем удобно компоновать ожидаемое и фактическое значение в одну строку.
							Форматирование строк с помощью f-strings
							
catalog_text = self.catalog_link.text # считываем текст и записываем его в переменную
assert catalog_text == "Каталог", \
    f"Wrong language, got {catalog_text} instead of 'Каталог'"  

									unittest
Тест-раннеры сами находят тестовые методы в указанных при запуске файлах, но для этого нужно следовать общепринятым правилам. 
Общее правило для всех фреймворков: название тестового метода должно начинаться со слова "test_".  
Дальше может идти любой текст, который является уникальным названием для теста:

def test_name_for_your_test():
Для unittest существуют собственные дополнительные правила:

-Тесты обязательно должны находиться в специальном тестовом классе.
-Вместо assert должны использоваться специальные assertion методы.
							Фиксируем пакеты в requirements.txt 
pip freeze > requirements.txt   #Эта команда сохранит все версии пакетов в специальный файл requirements.txt.
pip install -r requirements.txt  #В свежем окружении все пакеты установлены одной командой!

							PyTest: правила запуска тестов 
							
Когда мы выполняем команду pytest, тест-раннер собирает все тесты для запуска по определенным правилам:
если мы не передали никакого аргумента в команду, а написали просто pytest, тест-раннер начнёт поиск в текущей директории
как аргумент можно передать файл, путь к директории или любую комбинацию директорий и файлов, например: 

pytest scripts/selenium_scripts
# найти все тесты в директории scripts/selenium_scripts

pytest test_user_interface.py
# найти и выполнить все тесты в файле 

pytest scripts/drafts.py::test_register_new_user_parametrized
# найти тест с именем test_register_new_user_parametrized в указанном файле в указанной директории и выполнить 

--дальше происходит рекурсивный поиск: то есть PyTest обойдет все вложенные директории
--во всех директориях PyTest ищет файлы, которые удовлетворяют правилу  test_*.py или *_test.py 
(то есть начинаются на test_ или заканчиваются _test и имеют расширение .py)
--внутри всех этих файлов находит тестовые функции по следующему правилу:
	--все тесты, название которых начинается с test, которые находятся вне классов
	--все тесты, название которых начинается с test внутри классов, имя которых начинается с Test (и без метода __init__ внутри класса)
	
					Полезные команды для манипуляции выводом тестов PyTest
py.test test_sample.py --collect-only  # collects information test suite

py.test test_sample.py -v  # outputs verbose messages

py.test -q test_sample.py  # omit filename output

python -m pytest -q test_sample.py  # calling pytest through python

py.test --markers  # show available markers

# In order to create a reusable marker.
/*
# content of pytest.ini
[pytest]
markers =
    webtest: mark a test as a webtest.
*/

py.test -k "TestClass and not test_one"  # only run tests with names that match the "string expression"

py.test test_server.py::TestClass::test_method  # cnly run tests that match the node ID

py.test -x  # stop after first failure

py.test --maxfail=2  # stop after two failures

py.test --showlocals  # show local variables in tracebacks
py.test -l  # (shortcut)

py.test --tb=long  # the default informative traceback formatting
py.test --tb=native  # the Python standard library formatting
py.test --tb=short  # a shorter traceback format
py.test --tb=line  # only one line per failure
py.test --tb=no  # no tracebak output

py.test -x --pdb # drop to PDB on first failure, then end test session

py.test --durations=10  # list of the slowest 10 test durations.

py.test --maxfail=2 -rf  # exit after 2 failures, report fail info.

py.test -n 4  # send tests to multiple CPUs

py.test -m slowest  # run tests with decorator @pytest.mark.slowest or slowest = pytest.mark.slowest; @slowest

py.test --traceconfig  # find out which py.test plugins are active in your environment.

py.test --instafail  # if pytest-instafail is installed, show errors and failures instantly instead of waiting until the end of test suite.

# Test using parametrize
/*
    import pytest


    @pytest.mark.parametrize(
        ('n', 'expected'), [
            (1, 2),
            (2, 3),
            (3, 4),
            (4, 5),
            pytest.mark.xfail((1, 0)),
            pytest.mark.xfail(reason="some bug")((1, 0)),
            pytest.mark.skipif('sys.version_info >= (3,0)')((10, 11)),
        ]
    )
    def test_increment(n, expected):
        assert n + 1 == expected
*/
								Маркировка тестов
Для выборочного запуска таких тестов в PyTest используется маркировка тестов или метки (marks).
Для маркировки теста нужно написать декоратор вида @pytest.mark.mark_name, где mark_name — произвольная строка.

Чтобы запустить тест с нужной маркировкой, нужно передать в командной строке параметр -m и нужную метку:

pytest -s -v -m назввание_метки test_name.py

							регистрирация меток
Создайте файл pytest.ini в корневой директории вашего тестового проекта и добавьте в файл следующие строки:

[pytest]
markers =
    smoke: marker for smoke tests
    regression: marker for regression tests
Текст после знака ":" является поясняющим — его можно не писать.
